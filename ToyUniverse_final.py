#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 15 15:08:35 2018

@author: jenniferlaing
"""

import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from scipy import signal
#from scipy import ndimage



#-----------------------------------------------(1) generate flux densities
#---------------function: (I'm using a lower(s) to avoid confusion with sympy)
#f(s) = s^(-2.25)
#alpha(s) = integrate(s^(-2.25))
#then find inverse to get some function of alpha.
s, alpha = sp.symbols('s alpha')
expr = s**(-2.25)
expr
intg = sp.integrate(expr)
print(intg)

'''
Result: 
alpha(S) = -0.8 s**(-1.25)
s(alpha) = -1.25 * alpha**(-0.8)

'''



#(Part 1) -----------------------------------Generate Flux Densities

#range from which to choose samples
n = np.linspace(0.0,1.0,50000).tolist()

sample_n = np.random.rand(50000)
print(np.shape(sample_n))

plt.plot(sample_n)
plt.xlim(0,500)
plt.xlabel('# of samples')
plt.ylabel('Range from 0-1')
plt.title('Plot of Random numbers')
plt.savefig("Output_images/RandomNumbers_sample.png",dpi=300)
plt.show()

#-----------------------------------The function S(alpha)
#"sample_n" is the array of random values for alpha put through the function
#introduced a negative constant to remove the minus sign
S_alpha = (1.25 * sample_n**(-0.8)) 
S_alpha *= 1e-5/np.min(S_alpha) #shift the minimum value down to 1e-5
S_alpha = S_alpha[np.where(S_alpha < 0.1)] #remove values S > 0.1 Jy
S_min = np.log10(np.min(S_alpha) * 0.95)
S_max = np.log10(np.max(S_alpha) * 1.05)


plt.plot(S_alpha)
plt.xlabel('# of samples')
plt.ylabel('Intensity [arb]')
plt.savefig("Output_images/RandomIntensities.png",dpi=300)
plt.show()

#histogram of random numbers
xbins = np.logspace(-3,0,100)
h = plt.hist(sample_n,bins=xbins, normed=True)
plt.xscale("log")
plt.yscale("log")
plt.xlabel('bins (log)')
plt.ylabel('# of samples in bins')
plt.title('log-log histogram or random samples')
plt.show()

#---------------------------------histogram of transformation to S(alpha)
x_log = np.logspace(S_min,S_max,100)
xbins_log = np.logspace(S_min,S_max,100)

#plot the histogram
h = plt.hist(S_alpha,bins=xbins_log, normed=True, label='histogram')

#---------------------------------polyfit routine for first order polynomial
pfit = np.polyfit(np.log10(xbins_log[0:50]), np.log10(h[0][0:50]), 1)
print("slope generated by polynomial fit:", pfit)

#plot the line of best fit
#plt.plot(x_log,(x_log**-2.25)*1e-6)
plt.plot(xbins_log,10**(pfit[1] + pfit[0] * np.log10(xbins_log)), label='best fit: slope=-2.22')
plt.xscale("log")
plt.yscale("log")
plt.xlabel('bins (log)')
plt.ylabel('# of samples in bins')
plt.title('log-log histogram with function S(alpha) applied')
plt.legend()
plt.savefig("Output_images/loglogHist_withfit.png",dpi=300)
plt.show()




#(Part 2) -----------------------------------Populate 2-D Image Array

#create a blank 2-D array, decide on pixel size
#Example: im_size = np.zeros([900,900]) #_4 arcseconds per pixel

"""for reference
1 degree square: each side has 3600 arcseconds.
We want to properly sample the 15 arcsecond beam but not oversample.
So, we want at least 4 arcseconds per pixel

3600/2
Out[55]: 1800.0

3600/3
Out[58]: 1200.0

3600/4
Out[56]: 900.0  *** chosen

3600/5
Out[57]: 720.0  *

3600/6
Out[13]: 600.0  *

3600/9
Out[59]: 400.0

3600/15
Out[60]: 240.0

"""
N = 900  #number of pixels along one axis
div = 4  #number of arcseconds per pixel
im = np.zeros([N,N])

x_coord = np.random.randint(0,N,50000)
y_coord = np.random.randint(0,N,50000)

#scatter plot of a sample of coordinate points in the image
plt.scatter(x_coord[:200], y_coord[:200])
plt.gca().set_aspect('equal', adjustable='box')
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title("Scatter plot of a sample of points")
plt.savefig("Output_images/scatterPlot.png",dpi=300)
plt.show()



#----------------------------------------------populate the image
#if a pixel has more than one flux density, add them
for i in np.arange(len(S_alpha)):
    if im[x_coord[i],y_coord[i]] != 0:
        im[x_coord[i],y_coord[i]] = im[x_coord[i],y_coord[i]] + S_alpha[i]
    else:
        im[x_coord[i],y_coord[i]] = S_alpha[i]
    
plt.imshow(np.log10(im))
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title("2D_image_BeforeConv")
plt.savefig("Output_images/2D_image_BeforeConv.png",dpi=300)
plt.show()


#(Part 3) -----------------------------------Generate Beam and Convolve
#--------------------------------------------Gaussian Distribution
#2D grid for plotting
nx = np.linspace(-10,10,N)
ny = np.linspace(-10,10,N)
FWHM = 15/div  # 15 arcseconds / (arcsecs/pixel)
sig = FWHM/(np.sqrt(8 * np.log(2)))  # = FWHM/2.35

nxx,nyy = np.meshgrid(nx,ny)

#Define a 1D gaussian function:    
def gaussian(x, mu, sig):
    return np.exp(-(x - mu)**2 / (2 * sig**2))

#I defined a 2D gaussian function, but am getting unexpected results when plotting this on a meshgrid
def gaussian2D(x,y, mux, muy, sig):
    normalize = 1/np.sqrt(2*np.pi*sig**2)
    return normalize * (np.exp(-(x - mux)**2 + (y - muy)**2 / (2 * sig**2)))

#this Gaussian function using a covariance matrix was shown in the cta200h course, 
#lecture 8 on Numerical computations through random sampling - the resulting 2D image seems better.
#https://github.com/ttricco/cta200h/blob/master/lecture8/monte_carlo.ipynb
cov_xx = FWHM/N 
cov_yy = FWHM/N
cov_xy = 0.0
cov = np.array([[cov_xx,cov_xy],[cov_xy,cov_yy]])
invcov = np.linalg.inv(cov)

def gauss2D(x,y,cov,invcov):
    det = np.linalg.det(cov)
    norm = 1/(2*np.pi) / det**0.5
    return norm * np.exp(-0.5*(x*(invcov[0,0]*x + invcov[0,1]*y) + y*(invcov[1,0]*x + invcov[1,1]*y)))

#Calculate the Point Spread Function (PSF)
#1D Gaussian
psf1D = gaussian(nxx, 0., sig)

#2D Gaussian
psf2D_g = gaussian2D(nxx, nyy, 0, 0, sig)
psf2D_gn = psf2D_g / np.max(psf2D_g) #to normalize

#2D Gaussian - used this to create the 2D image of the gaussian
psf2Dcov = gauss2D(nxx, nyy, cov, invcov)
psf2D = psf2Dcov / np.max(psf2Dcov) #to normalize


#plot line graph of 1D gaussian
plt.plot(psf1D[0])
plt.xlabel('x range [pixels]')
plt.ylabel('y range [0-1]')
plt.title("Gaussian plot")
plt.savefig("Output_images/1DGaussian_plot.png",dpi=300)
plt.show()

#image of 1D gaussian
plt.imshow(psf1D)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title("image of 1D PSF")
plt.colorbar()
plt.savefig("Output_images/1DGaussian_image.png",dpi=300)
plt.show()

#image of 2D gaussian
plt.imshow(psf2D_gn)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title("image of 2D PSF")
plt.colorbar()
#plt.savefig("Output_images/2DGaussian_image_g.png",dpi=300)
plt.show()

#image of 2D gaussian - Using covariance matrix
plt.imshow(psf2D)
plt.xlim(430,470)
plt.ylim(430,470)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title("image of 2D PSF - using covariance matrix")
plt.colorbar()
plt.savefig("Output_images/2DGaussian_image.png",dpi=300)
plt.show()

#coutour image on Meshgrid
c = plt.contourf(nxx,nyy,psf2D, cmap='Blues')
plt.gca().set_aspect('equal', adjustable='box')
plt.xlim(-0.5,0.5)
plt.ylim(-0.5,0.5)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Meshgrid - Contour')
plt.colorbar()
plt.savefig("Output_images/contour.png",dpi=300)
plt.show()



#--------------------------------------------2D Convolution of beam and image

Cnv = signal.fftconvolve(im, psf2D, mode='same')

plt.imshow(Cnv)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Beam Convolved Image')
plt.colorbar()
plt.savefig("Output_images/2D_convImage.png",dpi=300)
plt.show()

plt.imshow(Cnv, cmap='Blues')
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Beam Convolved Image')
plt.colorbar()
plt.savefig("Output_images/2D_convImageBlue.png",dpi=300)
plt.show()


#(Part 4) -----------------------------------Generate Gaussian random noise

mu = 0
sigma = 3e-5
Gauss_noise = np.random.normal(mu,sigma,N**2).reshape(N,N)

plt.imshow(Gauss_noise)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Gauss Noise Image')
plt.colorbar()
plt.savefig("Output_images/2D_GaussNoise.png",dpi=300)
plt.show()

#Convolve the gaussian noise with the 2D gaussian beam
CnvNoise = signal.fftconvolve(Gauss_noise, psf2D, mode='same')

plt.imshow(CnvNoise)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Gauss Noise Convolved Image')
plt.colorbar()
plt.savefig("Output_images/2D_convNoise.png",dpi=300)
plt.show()

#------------------------plot a histogram of the beam convolved noise image

CnvNmin = np.min(CnvNoise)
CnvNmax = np.max(CnvNoise)
xaxis = np.linspace(CnvNmin, CnvNmax, N)
xbins = np.linspace(CnvNmin, CnvNmax, 80)
CnvN_med = np.median(CnvNoise, axis=1)

hG = plt.hist(CnvN_med, bins=xbins, label="Histogram")
plt.plot(xaxis,psf1D[0]*310, label="Gaussian: sigma = 3e-5")
#plt.xlim(-0.002,0.002)
plt.xlabel('bins')
plt.ylabel('# of samples in bins')
plt.title('histogram of Gaussian noise convolved image')
plt.legend()
plt.savefig("Output_images/Hist_gaussNoise.png",dpi=300)
plt.show()

#----------------------add convolved noise image and beam convolved sources
Noise_im = Cnv + CnvNoise

#create image of noise + Convolved image
plt.imshow(Noise_im)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Convolved Image + Noise')
plt.colorbar()
plt.savefig("Output_images/Im_Noise_image.png",dpi=300)
plt.show()

#create image of noise + Convolved image
plt.imshow(Noise_im, cmap='Blues')
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Convolved Image + Noise')
plt.colorbar()
plt.savefig("Output_images/Im_Noise_imageBlue.png",dpi=300)
plt.show()

#zoom in on image
plt.imshow(Noise_im)
plt.xlim(400,600)
plt.ylim(400,600)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Convolved Image + Noise')
plt.colorbar()
plt.savefig("Output_images/Im_Noise_image_zoom.png",dpi=300)
plt.show()

#zoom in on image
plt.imshow(Noise_im, cmap='Blues')
plt.xlim(400,600)
plt.ylim(400,600)
plt.xlabel('x range [pixels]')
plt.ylabel('y range [pixels]')
plt.title('Convolved Image + Noise')
plt.colorbar()
plt.savefig("Output_images/Im_Noise_image_zoomBlue.png",dpi=300)
plt.show()




